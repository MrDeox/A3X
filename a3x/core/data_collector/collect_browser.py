# a3x/core/data_collector/collect_browser.py\n\n\"\"\"Collector for extracting browsing patterns from browser history (SQLite).\"\"\"\n\nimport sqlite3\nimport datetime\nimport os\nimport shutil\nfrom .collector_base import BaseCollector\n\n# Potential paths (adjust for your OS/browser)\n# Linux Firefox: ~/.mozilla/firefox/<profile>/places.sqlite\n# Linux Chrome/Chromium: ~/.config/google-chrome/Default/History or ~/.config/chromium/Default/History\n# Windows paths are different\n\nDEFAULT_FIREFOX_PATH = os.path.expanduser(\"~/.mozilla/firefox\")\nDEFAULT_CHROME_PATH = os.path.expanduser(\"~/.config/google-chrome/Default/History\")\nDEFAULT_CHROMIUM_PATH = os.path.expanduser(\"~/.config/chromium/Default/History\")\n\nclass BrowserCollector(BaseCollector):\n    def __init__(self):\n        super().__init__(source_name=\"browser\")\n\n    def _find_firefox_profile(self):\n        \"\"\"Tries to find the default Firefox profile directory.\"\"\"\n        if not os.path.exists(DEFAULT_FIREFOX_PATH):\n            return None\n        for item in os.listdir(DEFAULT_FIREFOX_PATH):\n            if item.endswith(('.default-release', '.default')):\n                profile_path = os.path.join(DEFAULT_FIREFOX_PATH, item, \"places.sqlite\")\n                if os.path.exists(profile_path):\n                    print(f\"Found Firefox profile DB: {profile_path}\")\n                    return profile_path\n        print(\"Firefox profile DB (places.sqlite) not found in default location.\")\n        return None\n\n    def _get_history_db_path(self, browser=\'firefox\'):\n        path = None\n        if browser == \'firefox\':\n            path = self._find_firefox_profile()\n        elif browser == \'chrome\':\n            path = DEFAULT_CHROME_PATH\n        elif browser == \'chromium\':\n            path = DEFAULT_CHROMIUM_PATH\n        \n        if path and os.path.exists(path):\n            return path\n        else:\n            print(f\"{browser.capitalize()} history database not found at expected path: {path}\")\n            return None\n\n    def _copy_db_safely(self, db_path):\n        \"\"\"Copies the DB to a temp location to avoid locking issues.\"\"\"\n        if db_path is None:\n            return None\n        # Create a unique temp name\n        temp_db_path = os.path.join(os.path.dirname(db_path), f\"{os.path.basename(db_path)}_{os.getpid()}_temp_copy\")\n        try:\n            shutil.copy2(db_path, temp_db_path)\n            print(f\"Database copied to temporary location: {temp_db_path}\")\n            return temp_db_path\n        except Exception as e:\n            print(f\"Error copying database {db_path} to {temp_db_path}: {e}\")\n            # Clean up if copy failed partially\n            if os.path.exists(temp_db_path):\n                os.remove(temp_db_path)\n            return None\n\n    def _cleanup_temp_db(self, temp_db_path):\n        if temp_db_path and os.path.exists(temp_db_path):\n            try:\n                os.remove(temp_db_path)\n                print(f\"Temporary database removed: {temp_db_path}\")\n            except OSError as e:\n                print(f\"Error removing temporary DB copy {temp_db_path}: {e}\")\n\n    def collect(self, browser=\'firefox\', time_limit_days=30):\n        \"\"\"Collects browser history based on sequential navigation.\n\n        Args:\n            browser (str): 'firefox', 'chrome', or 'chromium'.\n            time_limit_days (int): How many past days of history to collect.\n\n        Returns:\n            list: A list of formatted records.\n        \"\"\"\n        db_path_original = self._get_history_db_path(browser)\n        if not db_path_original:\n            return []\n\n        db_path_copy = self._copy_db_safely(db_path_original)\n        if not db_path_copy:\n            return []\n\n        records = []\n        conn = None\n        try:\n            conn = sqlite3.connect(db_path_copy)\n            # Set row factory to access columns by name\n            conn.row_factory = sqlite3.Row \n            cursor = conn.cursor()\n\n            # --- Define Query based on browser --- \n            query = \"\"\n            params = []\n            if browser == \'firefox\':\n                query = \"\"\"\n                    SELECT p.url, p.title, h.visit_date \n                    FROM moz_places p JOIN moz_historyvisits h ON p.id = h.place_id \n                    WHERE h.visit_date >= ? \n                    ORDER BY h.visit_date ASC -- Order ASC to process chronologically\n                \"\"\"\n                # Firefox timestamp is microseconds since Unix epoch\n                cutoff_timestamp = (datetime.datetime.now() - datetime.timedelta(days=time_limit_days)).timestamp() * 1000000\n                params.append(cutoff_timestamp)\n            elif browser in [\'chrome\', \'chromium\']:\n                query = \"\"\"\n                    SELECT url, title, last_visit_time \n                    FROM urls \n                    WHERE last_visit_time >= ? \n                    ORDER BY last_visit_time ASC -- Order ASC to process chronologically\n                \"\"\"\n                # Chrome epoch is 1601-01-01. Convert current time cutoff.\n                epoch_diff_seconds = 11644473600 \n                cutoff_timestamp = ((datetime.datetime.now() - datetime.timedelta(days=time_limit_days)).timestamp() + epoch_diff_seconds) * 1000000\n                params.append(cutoff_timestamp)\n            else:\n                self._cleanup_temp_db(db_path_copy)\n                return []\n\n            print(f\"Executing query on {browser} history database...\")\n            cursor.execute(query, tuple(params))\n\n            # --- Process Results Sequentially --- \n            previous_url = None\n            previous_title = None\n            count = 0\n            
            for row in cursor.fetchall():\n                current_url = row['url']\n                current_title = row['title'] if row['title'] else \"No Title\"\n                timestamp_microseconds = row[2] # visit_date or last_visit_time\n                
                # Convert timestamp to datetime\n                visit_time = None\n                try:\n                    if browser == 'firefox':\n                        visit_time = datetime.datetime.fromtimestamp(timestamp_microseconds / 1000000)\n                    else: # Chrome/Chromium\n                        visit_time = datetime.datetime.fromtimestamp((timestamp_microseconds / 1000000) - epoch_diff_seconds)\n                except Exception as time_e:\n                    print(f\"  Skipping record due to timestamp conversion error: {time_e}\")\n                    continue\n\n                # Create record based on previous visit\n                if previous_url is not None:\n                    input_text = previous_url\n                    context = previous_title\n                    response = current_url\n                    reasoning = \"Navegação Sequencial\"\n                    
                    records.append(self._format_record(\n                        input_text=input_text,\n                        context=context,\n                        response=response,\n                        reasoning=reasoning,\n                        timestamp=visit_time\n                    ))\n                    count += 1\n                
                # Update previous visit info for the next iteration\n                previous_url = current_url\n                previous_title = current_title\n            
            print(f\"Processed {count} sequential navigation records.\")\n\n        except sqlite3.Error as e:\n            print(f\"SQLite error accessing {browser} history: {e}\")\n        except Exception as e:\n            print(f\"An error occurred processing {browser} history: {e}\")\n        finally:\n            if conn:\n                conn.close()\n            # Clean up the copied database\n            self._cleanup_temp_db(db_path_copy)\n                    
        return records\n\n# --- Example Usage (for testing) ---\nif __name__ == \'__main__\':\n    # NOTE: This will attempt to read your *actual* browser history (if found)\n    # For a real test, ensure you have browsing history in the last N days.\n    \n    collector = BrowserCollector()\n    print(\"\n--- Testing Browser Collector ---\")\n    print(\"Collecting Firefox history (last 7 days)...")\n    firefox_records = collector.collect(browser=\'firefox\', time_limit_days=7)\n    print(f\"Collected {len(firefox_records)} sequential records from Firefox.\")\n    if firefox_records:\n         print(\"  Example record:\", firefox_records[0])\n\n    # print(\"\nCollecting Chrome history (last 7 days)...")\n    # chrome_records = collector.collect(browser=\'chrome\', time_limit_days=7)\n    # print(f\"Collected {len(chrome_records)} sequential records from Chrome.\")\n    # if chrome_records:\n    #      print(\"  Example record:\", chrome_records[0])\n    print(\"--- Browser Collector Test Finished ---\")\n 