# a3x/core/data_collector/collect_whatsapp.py\n\n\"\"\"Collector for extracting decision patterns from WhatsApp chat exports (.txt).\"\"\"\n\nimport re\nimport datetime\nimport os\nfrom .collector_base import BaseCollector\n\n# Example Regex (adjust based on your WhatsApp export format - pt-BR example):\n# Format: DD/MM/AAAA HH:MM - Nome: Mensagem\n# Handles optional leading/trailing whitespace and variations in hyphen spacing\nMESSAGE_REGEX = re.compile(r"^\s*(\d{1,2}[/.]\d{1,2}[/.]\d{2,4})\s*,?\s*(\d{1,2}:\d{2})\s*[-–—]?\s*([^:]+?)\s*:\s*(.*)")
# Regex for multiline message continuation (doesn't start with the date/time pattern)
# CONTINUATION_REGEX = re.compile(r"^(?!\s*\d{1,2}[/.]\d{1,2}[/.]\d{2,4})", re.IGNORECASE)
\n\n# --- Configuration ---
# IMPORTANT: Set this to your exact name as it appears in the WhatsApp exports
# YOUR_NAME_IN_WHATSAPP = "Arthur"
# --- End Configuration ---
\n\nclass WhatsAppCollector(BaseCollector):\n    def __init__(self, your_name=YOUR_NAME_IN_WHATSAPP):\n        super().__init__(source_name="whatsapp")\n        self.your_name = your_name\n        if not self.your_name:\n            print("WARNING: YOUR_NAME_IN_WHATSAPP is not set in collect_whatsapp.py. Collector may not identify your messages correctly.")\n\n    def _parse_timestamp(self, date_str, time_str):\n        \"\"\"Tries to parse different date formats.\"\"\"\n        # Normalize date separator\n        date_str = date_str.replace('.', '/')\n        # Handle DD/MM/YY and DD/MM/YYYY\n        formats_to_try = ["%d/%m/%y %H:%M", "%d/%m/%Y %H:%M"]\n        for fmt in formats_to_try:\n            try:\n                return datetime.datetime.strptime(f"{date_str} {time_str}", fmt)\n            except ValueError:\n                continue\n        # Fallback or raise error if needed\n        print(f"Could not parse timestamp: {date_str} {time_str}")\n        return None\n\n    def collect(self, directory_path):\n        \"\"\"Parses all WhatsApp .txt export files found in a directory.\n\n        Args:\n            directory_path (str): Path to the directory containing WhatsApp .txt files.\n\n        Returns:\n            list: A list of formatted records (dictionaries) from all files.\n        \"\"\"\n        all_records = []\n        if not os.path.isdir(directory_path):\n            print(f"Error: WhatsApp export directory not found at {directory_path}")\n            return all_records\n\n        print(f"Scanning WhatsApp export directory: {directory_path}")\n        for filename in os.listdir(directory_path):\n            if filename.lower().endswith(".txt"):\n                file_path = os.path.join(directory_path, filename)\n                print(f"Processing file: {filename}")\n                try:\n                    with open(file_path, \'r\', encoding=\'utf-8\') as f:\n                        current_context = []\n                        last_author = None\n                        last_timestamp = None\n                        file_records = []\n\n                        for line in f:\n                            match = MESSAGE_REGEX.match(line)\n                            if match:\n                                date_str, time_str, author, message = match.groups()\n                                author = author.strip()\n                                message = message.strip()\n                                timestamp = self._parse_timestamp(date_str, time_str)\n\n                                if not timestamp:\n                                    print(f"  Skipping line due to timestamp parse error: {line.strip()}")\n                                    continue\n\n                                # --- Logic to identify Input/Response/Context --- \n                                if author == self.your_name:\n                                    if current_context: # Only consider your message a response if there's prior context\n                                        # Simplistic: last message is input\n                                        input_record = current_context[-1]\n                                        input_text = input_record[\'message\']\n                                        # Previous messages form context\n                                        context_records = current_context[:-1]\n                                        context_text = "\\n".join([f"{ctx['author']}: {ctx['message']}" for ctx in context_records])\n                                        response_text = message\n                                        # Reasoning: Start with empty, could be inferred later\n                                        reasoning = ""\n\n                                        file_records.append(self._format_record(\n                                            input_text=input_text,\n                                            context=context_text,\n                                            response=response_text,\n                                            reasoning=reasoning,\n                                            timestamp=timestamp\n                                        ))\n                                        # print(f"    -> Record created: Input='{input_text[:30]}...', Response='{response_text[:30]}...' ")\n                                        current_context = [] # Reset context after your response\n                                    else:\n                                        # Your message starts a context, or is standalone\n                                        # We currently only capture scenarios where you respond to others\n                                        pass\n                                else:\n                                    # Add messages from others to the context\n                                    current_context.append({'author': author, 'message': message, 'timestamp': timestamp})\n\n                                last_author = author\n                                last_timestamp = timestamp\n                            \n                            # Handle multi-line messages\n                            elif last_author and CONTINUATION_REGEX.match(line) and line.strip():\n                                if current_context:\n                                    # Append to the last message in the current context buffer\n                                    current_context[-1]['message'] += "\\n" + line.strip()\n                                elif last_author == self.your_name and file_records:\n                                    # Append to the last recorded response if it was yours\n                                    # Check if the last record's author matches (indirectly via your_name)\n                                    # This assumes your response was the last thing added to file_records\n                                    # A more robust way might involve checking timestamp proximity\n                                    # Let's simplify: assume multiline belongs to the *previous* parsed message block\n                                    # We need a better way to track the *active* message block being built\n                                    # For now, multiline responses might get cut if context reset.\n                                    # SAFER APPROACH: If the last message added to context was yours, append there.\n                                    # Let's reconsider. Multiline applies to the immediately preceding line's author.\n                                    # If last_author == self.your_name AND a record was just generated, append to *that* record's response?\n                                    # This gets complex. Let's just append to context if it exists.\n                                    pass # Difficult to reliably append to 'response' after context reset.\n                                else:\n                                    # Or append to the last message if context is empty (your message was first?)\n                                    pass # Ignore for now\n                            else:\n                                # Ignore system messages like "X added Y", media omissions, etc.\n                                # print(f"  Ignoring line: {line.strip()}")\n                                pass\n\n                    all_records.extend(file_records)\n                    print(f"  -> Found {len(file_records)} potential records in {filename}.")\n\n                except Exception as e:\n                    print(f"Error processing file {file_path}: {e}")\n\n        print(f"Finished processing WhatsApp directory. Total records found: {len(all_records)}.")\n        return all_records\n\n# --- Example Usage (for testing) ---\nif __name__ == \'__main__\':\n    # Create a dummy directory and files for testing\n    test_dir = "dummy_whatsapp_exports"\n    os.makedirs(test_dir, exist_ok=True)\n    dummy_data1 = """\n11/04/24 10:00 - Amigo 1: Ei, quer sair amanhã?\n11/04/24 10:05 - Amigo 1: Vamos no cinema?\n11/04/24 10:15 - Arthur: pior que não vou conseguir, tô quebrado hoje\nVou precisar descansar.\n12/04/2024 15:30 - Colega 2: Preciso daquele relatório pra hoje.\n12/04/2024 15:32 - Arthur: Ok, já te mando.\n    """\n    dummy_data2 = """\n13/04/2024 09:00 - Outro Amigo: Bora jogar?\n13/04/2024 09:01 - Arthur: Agora não dá, tô no meio de um projeto aqui.\n    """\n    with open(os.path.join(test_dir, "chat1.txt"), \'w\', encoding=\'utf-8\') as f:\n        f.write(dummy_data1)\n    with open(os.path.join(test_dir, "chat2.txt"), \'w\', encoding=\'utf-8\') as f:\n        f.write(dummy_data2)\n    with open(os.path.join(test_dir, "not_a_chat.log"), \'w\') as f:\n        f.write("Some other log data")\n\n    # IMPORTANT: Make sure YOUR_NAME_IN_WHATSAPP is set correctly above!\n    collector = WhatsAppCollector()\n    collected_records = collector.collect(test_dir)\n\n    import json\n    print("\\n--- Collected Records Sample ---")\n    # Print only the first few records for brevity\n    print(json.dumps(collected_records[:3], indent=2, ensure_ascii=False))\n    print("-----------------------------")\n\n    # Clean up dummy directory and files\n    import shutil\n    shutil.rmtree(test_dir)\n    print(f"Cleaned up dummy directory: {test_dir}")\n 